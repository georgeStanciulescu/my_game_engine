/ float rotation{};
        // rotationSpeed = static_cast<float>(glfwGetTime()) * 10.0f;
        // for (unsigned int i{0};i < 1000;++i) // creating cubes
        // {
        //
        //     glm::mat4 model = glm::mat4(1.0f);
        //     auto stuff = glm::vec3(1.0f);
        //     auto t = static_cast<float>(glfwGetTime());
        //     model = glm::translate(model,glm::vec3(std::sin(i),i+std::cos(i),1.0f)); // changed the values to 1.0f
        //     //model = glm::translate(model,cubePositions[i]);
        //     if (!i)
        //     {
        //         rotation = rotationSpeed * 1.0f;
        //     }
        //     else
        //     {
        //         rotation = rotationSpeed * static_cast<float>(i) * 1.04f;
        //     }
        //     model = glm::rotate(model,glm::radians(rotation),glm::vec3(1.0f,0.3f,0.5f));
        //
        //     myShader.setMat4("transform",model);
        //
        //     glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(model))); // used for calculating the Normal in the vertex shader
        //     myShader.setMat3("inverseTransposeMatrix",normalMatrix);
        //
        //     glDrawArrays(GL_TRIANGLES, 0, 36);
        // }
